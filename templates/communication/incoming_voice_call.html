<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Incoming Voice Call</title>
    <link href="https://cdn.jsdelivr.net/npm/bootstrap@5.1.3/dist/css/bootstrap.min.css" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0/css/all.min.css" rel="stylesheet">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Helvetica, Arial, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            display: flex;
            align-items: center;
            justify-content: center;
            overflow: hidden;
            position: fixed;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            z-index: 2147483647;
        }

        .incoming-call-container {
            width: 100%;
            max-width: 600px;
            height: 100vh;
            background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            position: relative;
            overflow: hidden;
            z-index: 2147483647;
        }

        /* Animated background */
        .call-background {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            opacity: 0.1;
            background: url('data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 100 100"><circle cx="50" cy="50" r="40" fill="none" stroke="white" stroke-width="2"/></svg>');
            animation: pulse 3s ease-in-out infinite;
        }

        @keyframes pulse {
            0%, 100% { transform: scale(1); opacity: 0.1; }
            50% { transform: scale(1.1); opacity: 0.15; }
        }

        .caller-info {
            position: relative;
            z-index: 10;
            display: flex;
            flex-direction: column;
            align-items: center;
            margin-bottom: 60px;
        }

        .caller-avatar {
            width: 120px;
            height: 120px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            display: flex;
            align-items: center;
            justify-content: center;
            margin-bottom: 30px;
            box-shadow: 0 10px 40px rgba(102, 126, 234, 0.4);
            font-size: 48px;
            color: white;
            animation: scale-in 0.6s ease-out;
        }

        @keyframes scale-in {
            0% { transform: scale(0.5); opacity: 0; }
            100% { transform: scale(1); opacity: 1; }
        }

        .caller-name {
            color: white;
            font-size: 28px;
            font-weight: 600;
            margin-bottom: 10px;
            text-align: center;
        }

        .caller-role {
            color: rgba(255, 255, 255, 0.6);
            font-size: 14px;
            text-transform: uppercase;
            letter-spacing: 1px;
            margin-bottom: 20px;
        }

        .call-status {
            color: #4ade80;
            font-size: 14px;
            display: flex;
            align-items: center;
            gap: 6px;
        }

        .call-status .dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #4ade80;
            animation: blink 1s ease-in-out infinite;
        }

        @keyframes blink {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.3; }
        }

        /* Status display for busy/offline */
        .status-badge {
            position: absolute;
            top: 100px;
            left: 50%;
            transform: translateX(-50%);
            background: rgba(255, 152, 0, 0.9);
            color: white;
            padding: 10px 20px;
            border-radius: 25px;
            font-size: 14px;
            font-weight: 600;
            z-index: 14;
            display: none;
            align-items: center;
            gap: 8px;
            box-shadow: 0 4px 12px rgba(255, 152, 0, 0.4);
            animation: slideDown 0.3s ease-out;
        }

        .status-badge.busy {
            background: rgba(239, 68, 68, 0.9);
        }

        .status-badge.offline {
            background: rgba(107, 114, 128, 0.9);
        }

        .status-badge.attempting {
            background: rgba(59, 130, 246, 0.9);
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateX(-50%) translateY(-10px);
            }
            to {
                opacity: 1;
                transform: translateX(-50%) translateY(0);
            }
        }

        /* Call timer */
        .call-timer {
            color: rgba(255, 255, 255, 0.8);
            font-size: 16px;
            margin-top: 15px;
            font-weight: 500;
        }

        /* Action buttons */
        .call-actions {
            position: relative;
            z-index: 10;
            display: flex;
            gap: 40px;
            justify-content: center;
            align-items: center;
            margin-top: auto;
            margin-bottom: 60px;
            width: 100%;
        }

        .call-btn {
            width: 70px;
            height: 70px;
            border-radius: 50%;
            border: none;
            cursor: pointer;
            font-size: 28px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
            box-shadow: 0 8px 20px rgba(0, 0, 0, 0.3);
        }

        .call-btn:hover {
            transform: scale(1.1);
            box-shadow: 0 12px 30px rgba(0, 0, 0, 0.4);
        }

        .call-btn:active {
            transform: scale(0.95);
        }

        .accept-btn {
            background: linear-gradient(135deg, #4ade80 0%, #22c55e 100%);
            color: white;
        }

        .accept-btn:hover {
            background: linear-gradient(135deg, #22c55e 0%, #16a34a 100%);
        }

        .reject-btn {
            background: linear-gradient(135deg, #ef4444 0%, #dc2626 100%);
            color: white;
        }

        .reject-btn:hover {
            background: linear-gradient(135deg, #dc2626 0%, #b91c1c 100%);
        }

        /* Call control buttons (mute, speaker, hold) */
        .call-controls {
            position: absolute;
            top: 80px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 9;
            display: flex;
            gap: 15px;
            background: rgba(0, 0, 0, 0.3);
            padding: 12px 20px;
            border-radius: 50px;
            backdrop-filter: blur(10px);
        }

        .control-btn {
            width: 45px;
            height: 45px;
            border-radius: 50%;
            border: none;
            background: rgba(255, 255, 255, 0.2);
            color: white;
            cursor: pointer;
            font-size: 16px;
            display: flex;
            align-items: center;
            justify-content: center;
            transition: all 0.3s ease;
        }

        .control-btn:hover {
            background: rgba(255, 255, 255, 0.3);
            transform: scale(1.05);
        }

        .control-btn.active {
            background: #ef4444;
        }

        .control-btn.active:hover {
            background: #dc2626;
        }

        /* Ringtone animation */
        .ringtone-icon {
            animation: ring 0.6s ease-in-out infinite;
            position: absolute;
            top: 30px;
            right: 30px;
            font-size: 24px;
            color: #f59e0b;
            z-index: 10;
        }

        @keyframes ring {
            0%, 100% { transform: rotate(0deg); }
            25% { transform: rotate(-15deg); }
            75% { transform: rotate(15deg); }
        }

        /* Audio element */
        audio {
            display: none;
        }

        .close-btn {
            position: absolute;
            top: 20px;
            left: 20px;
            z-index: 15;
            background: rgba(255, 255, 255, 0.1);
            border: none;
            color: white;
            width: 40px;
            height: 40px;
            border-radius: 50%;
            cursor: pointer;
            font-size: 20px;
            transition: all 0.3s ease;
        }

        .close-btn:hover {
            background: rgba(255, 255, 255, 0.2);
        }

        /* Responsive */
        @media (max-width: 600px) {
            .incoming-call-container {
                max-width: 100%;
                border-radius: 0;
            }

            .caller-avatar {
                width: 100px;
                height: 100px;
                font-size: 40px;
            }

            .caller-name {
                font-size: 24px;
            }

            .call-actions {
                gap: 30px;
            }

            .call-btn {
                width: 60px;
                height: 60px;
                font-size: 24px;
            }
        }
    </style>
</head>
<body>
    <div class="incoming-call-container">
        <div class="call-background"></div>

        <!-- Status Badge for Busy/Offline -->
        <div class="status-badge" id="statusBadge"></div>

        <button class="close-btn" id="closeBtn" onclick="window.close()">
            <i class="fas fa-times"></i>
        </button>

        <div class="ringtone-icon">
            <i class="fas fa-phone"></i>
        </div>

        <!-- Call Control Buttons (appear after call accepted) -->
        <div class="call-controls" id="callControls" style="display: none;">
            <button class="control-btn" id="muteBtn" title="Mute Microphone">
                <i class="fas fa-microphone"></i>
            </button>
            <button class="control-btn" id="speakerBtn" title="Speaker">
                <i class="fas fa-volume-up"></i>
            </button>
            <button class="control-btn" id="holdBtn" title="Hold Call">
                <i class="fas fa-pause"></i>
            </button>
            {% if appointment and appointment.doctor and appointment.doctor.user_id == current_user.id %}
            <button class="control-btn" id="markConsultationCompleteBtn" title="Mark Consultation Complete" style="background:#06b6d4; color:#fff;">
                <i class="fas fa-check"></i>
            </button>
            {% endif %}
        </div>

        <div class="caller-info">
            <div class="caller-avatar" id="callerAvatar">
                    <span id="callerInitials">DR</span>
                    <img id="callerPic" src="" alt="Caller" style="display:none; width:100%; height:100%; object-fit:cover; position:absolute; inset:0;" />
                </div>
            <div class="caller-name" id="callerName">Dr. John Doe</div>
            <div class="caller-role" id="callerRole">Doctor</div>
            <div class="call-status">
                <span class="dot"></span>
                <span id="statusText">Calling...</span>
            </div>
            <div class="call-timer" id="callTimer">Ringing...</div>
        </div>

        <div class="call-actions">
            <button class="call-btn reject-btn" id="rejectBtn" title="Reject Call">
                <i class="fas fa-phone"></i>
            </button>
            <button class="call-btn accept-btn" id="acceptBtn" title="Accept Call">
                <i class="fas fa-phone"></i>
            </button>
        </div>

        <!-- Ringtone Audio -->
        <audio id="ringtoneAudio" loop>
            <source src="data:audio/wav;base64,UklGRiYAAABXQVZFZm10IBAAAAABAAEAQB8AAAB9AAACABAAZGF0YQIAAAAAAA==" type="audio/wav">
        </audio>
        <input type="hidden" id="currentUserId" value="{{ current_user.id if current_user else '' }}">
        <input type="hidden" id="appointmentDoctorUserId" value="{{ appointment.doctor.user_id if appointment and appointment.doctor else '' }}">
        <script>
            // Simple mark-complete modal wiring for incoming voice call (doctor-only)
            const appointmentDoctorUserId = document.getElementById('appointmentDoctorUserId')?.value || '';
            const currentUserId = document.getElementById('currentUserId')?.value || '';
            if (String(appointmentDoctorUserId) === String(currentUserId)) {
                // append modal
                const modalHtml = `<div id="markCompleteModalIncoming" style="display:none; position:fixed; inset:0; z-index:2000; align-items:center; justify-content:center; background:rgba(0,0,0,0.6)">`+
                    `<div style="background:#fff; color:#111; padding:20px; border-radius:10px; width:480px; max-width:95%;">`+
                    `<h5>Mark Consultation Complete</h5>`+
                    `<p class="text-muted">Add brief notes for the appointment (optional). Notes autosave while typing.</p>`+
                    `<div class="mb-2"><textarea id="completeNotesIncoming" class="form-control" rows="4" placeholder="Summary notes..."></textarea></div>`+
                    `<div class="d-flex justify-content-end gap-2"><button id="cancelMarkCompleteIncoming" class="btn btn-secondary">Cancel</button><button id="saveMarkCompleteIncoming" class="btn btn-primary">Mark Complete</button></div>`+
                    `</div></div>`;
                document.body.insertAdjacentHTML('beforeend', modalHtml);

                document.getElementById('markConsultationCompleteBtn')?.addEventListener('click', (e) => {
                    e.preventDefault(); document.getElementById('markCompleteModalIncoming').style.display = 'flex';
                });

                let autosaveTimerInc = null;
                document.body.addEventListener('input', (ev) => {
                    if (ev.target && ev.target.id === 'completeNotesIncoming') {
                        if (autosaveTimerInc) clearTimeout(autosaveTimerInc);
                        autosaveTimerInc = setTimeout(() => saveIncoming(true), 1500);
                    }
                });

                async function saveIncoming(isAutosave=false) {
                    const notes = document.getElementById('completeNotesIncoming').value;
                    try {
                        // Try to use global csrf token or fall back to hidden input
                        const _csrf = (typeof window !== 'undefined' && window.csrf_token) ? window.csrf_token : (document.querySelector('input[name="csrf_token"]') ? document.querySelector('input[name="csrf_token"]').value : '');
                        const resp = await fetch('/api/appointments/{{ appointment.id if appointment else "null" }}/complete', {
                            method: 'POST', credentials: 'same-origin', headers: {'Content-Type':'application/json', 'X-CSRFToken': _csrf}, body: JSON.stringify({ notes })
                        });
                        if (resp.ok) {
                            document.getElementById('saveMarkCompleteIncoming').disabled = true; document.getElementById('saveMarkCompleteIncoming').textContent = 'Marked Complete';
                            if (!isAutosave) { alert('Marked complete'); document.getElementById('markCompleteModalIncoming').style.display='none'; }
                        } else { if (!isAutosave) alert('Failed to mark complete'); }
                    } catch (err) { console.error(err); if (!isAutosave) alert('Error marking complete'); }
                }

                document.getElementById('cancelMarkCompleteIncoming')?.addEventListener('click', (e)=>{ e.preventDefault(); document.getElementById('markCompleteModalIncoming').style.display='none'; });
                document.getElementById('saveMarkCompleteIncoming')?.addEventListener('click', (e)=>{ e.preventDefault(); saveIncoming(false); });
                    }
                </script>
    </div>

    <script src="https://cdn.socket.io/4.5.4/socket.io.min.js"></script>
    <script>
        // Safe storage utility to handle Tracking Prevention
        const safeStorage = {
            getItem: function(key) {
                try {
                    return sessionStorage.getItem(key);
                } catch (e) {
                    console.warn('sessionStorage blocked by tracking prevention, using fallback');
                    return window[`__storage_${key}`] || null;
                }
            },
            setItem: function(key, value) {
                try {
                    sessionStorage.setItem(key, value);
                } catch (e) {
                    console.warn('sessionStorage blocked, using fallback storage');
                    window[`__storage_${key}`] = value;
                }
            },
            removeItem: function(key) {
                try {
                    sessionStorage.removeItem(key);
                } catch (e) {
                    delete window[`__storage_${key}`];
                }
            }
        };

        // Get call data from URL or session storage
        const callData = JSON.parse(safeStorage.getItem('incomingCallData') || '{}');
        const appointmentId = callData.appointment_id || new URLSearchParams(window.location.search).get('appointment_id');
        const callerId = callData.caller_id;
        const callerName = callData.caller_name || 'Unknown';
        const callerRole = callData.caller_role || 'Doctor';
        const callerProfilePic = callData.caller_profile_pic || new URLSearchParams(window.location.search).get('caller_profile_pic') || '';

        // Initialize Socket.IO (reuse global instance if present)
        if (!window.socket) { try { window.socket = io(); } catch(e) { console.error('Socket init failed', e); window.socket = null; } }
        var socket = window.socket;

        // DOM Elements
        const callerAvatarEl = document.getElementById('callerAvatar');
        const callerNameEl = document.getElementById('callerName');
        const callerRoleEl = document.getElementById('callerRole');
        const acceptBtn = document.getElementById('acceptBtn');
        const rejectBtn = document.getElementById('rejectBtn');
        const ringtoneAudio = document.getElementById('ringtoneAudio');
        const statusText = document.getElementById('statusText');
        const callTimer = document.getElementById('callTimer');
        const callerInitials = document.getElementById('callerInitials');
        const statusBadge = document.getElementById('statusBadge');

        // Display status badge
        function showStatusBadge(type, message) {
            statusBadge.textContent = message;
            statusBadge.className = `status-badge ${type}`;
            statusBadge.style.display = 'flex';
            
            // Disable accept button if busy
            if (type === 'busy') {
                acceptBtn.disabled = true;
                acceptBtn.style.opacity = '0.5';
                acceptBtn.title = 'User is currently busy';
            }
        }

        // Socket event listeners
        socket.on('connect', () => {
            console.log('Connected to socket server');
        });

        // Handle busy notification
        socket.on('call_failed_busy', (data) => {
            clearInterval(ringtoneInterval);
            showStatusBadge('busy', `⚠️ ${data.callee_name} is currently busy`);
            statusText.textContent = 'User Busy';
            
            setTimeout(() => {
                window.close();
            }, 5000);
        });

        // Handle offline/attempting connection
        socket.on('call_ringing', (data) => {
            if (data.status === 'offline_attempting') {
                showStatusBadge('attempting', `⏳ Attempting to reach ${data.message}...`);
            }
        });

        // Handle connection failed
        socket.on('voice_call_connection_failed', (data) => {
            clearInterval(ringtoneInterval);
            statusText.textContent = 'Connection Failed';
            statusBadge.className = 'status-badge';
            statusBadge.innerHTML = '<i class="fas fa-exclamation-circle"></i> Unable to connect';
            statusBadge.style.background = 'rgba(239, 68, 68, 0.9)';
            statusBadge.style.display = 'flex';
            
            setTimeout(() => {
                window.close();
            }, 5000);
        });

        // Audio stream variables
        let localStream = null;
        let peerConnection = null;
        let ringtoneInterval = null;

        // Set caller info
        callerNameEl.textContent = callerName;
        callerRoleEl.textContent = callerRole;

        // Display profile picture if available, otherwise show initials (with graceful fallback)
        if (callerProfilePic) {
            const picEl = document.getElementById('callerPic');
            picEl.src = callerProfilePic;
            picEl.style.display = 'block';
            callerInitials.style.display = 'none';
            picEl.onerror = function() {
                this.style.display = 'none';
                callerInitials.style.display = 'flex';
            };
        } else {
            const names = callerName.split(' ');
            const initials = names.map(n => n.charAt(0)).join('').substring(0, 2).toUpperCase();
            callerInitials.textContent = initials;
        }

        // Play ringtone using female voice and dual-tone pattern
        function playRingtone() {
            try {
                const audioContext = new (window.AudioContext || window.webkitAudioContext)();
                
                function playTone(frequency, duration) {
                    const oscillator = audioContext.createOscillator();
                    const gain = audioContext.createGain();
                    
                    oscillator.connect(gain);
                    gain.connect(audioContext.destination);
                    
                    oscillator.frequency.value = frequency;
                    oscillator.type = 'sine';
                    
                    gain.gain.setValueAtTime(0.15, audioContext.currentTime);
                    gain.gain.exponentialRampToValueAtTime(0.01, audioContext.currentTime + duration);
                    
                    oscillator.start(audioContext.currentTime);
                    oscillator.stop(audioContext.currentTime + duration);
                }
                
                // Female voice-like ringtone pattern: higher frequencies
                ringtoneInterval = setInterval(() => {
                    playTone(850, 0.4);   // First tone
                    setTimeout(() => playTone(950, 0.4), 500);  // Second tone
                }, 2000);
                
                playTone(850, 0.4);   // Initial tone
            } catch (e) {
                console.log('Audio context error:', e);
            }
        }

        // Start ringtone
        playRingtone();

        // Accept call
        acceptBtn.addEventListener('click', async () => {
            clearInterval(ringtoneInterval);
            statusText.textContent = 'Accepted';
            callTimer.textContent = 'Connecting...';
            
            // Initialize audio stream
            try {
                localStream = await navigator.mediaDevices.getUserMedia({
                    audio: {
                        echoCancellation: true,
                        noiseSuppression: true,
                        autoGainControl: true,
                        latency: 0.01,
                        channelCount: 1,
                        sampleRate: 48000
                    }
                });

                // Create peer connection
                const rtcConfig = {
                    iceServers: [
                        { urls: ['stun:stun.l.google.com:19302', 'stun:stun1.l.google.com:19302'] }
                    ]
                };

                peerConnection = new RTCPeerConnection(rtcConfig);

                // Add local audio tracks
                localStream.getTracks().forEach(track => {
                    if (track.kind === 'audio') {
                        track.enabled = true;
                        console.log('Local audio track enabled:', track.label);
                    }
                    peerConnection.addTrack(track, localStream);
                });

                // Handle remote audio stream
                peerConnection.ontrack = (event) => {
                    console.log('Remote track received:', event.track.kind);
                    if (event.track.kind === 'audio') {
                        let remoteAudio = document.getElementById('remoteAudio');
                        if (!remoteAudio) {
                            remoteAudio = document.createElement('audio');
                            remoteAudio.id = 'remoteAudio';
                            remoteAudio.autoplay = true;
                            remoteAudio.playsinline = true;
                            document.body.appendChild(remoteAudio);
                        }
                        remoteAudio.srcObject = event.streams[0];
                        remoteAudio.volume = 1;
                        console.log('Remote audio track connected:', event.track.label);
                        statusText.textContent = 'Connected';
                    }
                };

                // Handle ICE candidates
                peerConnection.onicecandidate = (event) => {
                    if (event.candidate) {
                        socket.emit('webrtc_ice_candidate', {
                            appointment_id: appointmentId,
                            candidate: event.candidate
                        });
                    }
                };

                // Join voice room
                socket.emit('join_voice_room', { appointment_id: appointmentId });

                // Create and send answer
                const offer = await new Promise((resolve) => {
                    socket.on('webrtc_offer', (data) => {
                        resolve(data.offer);
                    });
                });

                await peerConnection.setRemoteDescription(new RTCSessionDescription(offer));

                const answer = await peerConnection.createAnswer();
                await peerConnection.setLocalDescription(answer);

                socket.emit('webrtc_answer', {
                    appointment_id: appointmentId,
                    answer: answer
                });

            } catch (error) {
                console.error('Error accepting call:', error);
                statusText.textContent = 'Connection error';
            }
            
            // Signal acceptance to parent window via safeStorage
            safeStorage.setItem('callResponse', 'accepted');
            
            // Show call control buttons
            const callControls = document.getElementById('callControls');
            if (callControls) {
                callControls.style.display = 'flex';
            }
            
            // Initialize call control handlers
            initializeCallControls();
            
            // Don't redirect immediately, keep the call active
            // Redirect only when call ends
        });

        // Call control state variables
        let isMuted = false;
        let isSpeakerOn = false;
        let isOnHold = false;

        // Initialize call controls
        function initializeCallControls() {
            const muteBtn = document.getElementById('muteBtn');
            const speakerBtn = document.getElementById('speakerBtn');
            const holdBtn = document.getElementById('holdBtn');

            // Mute button
            if (muteBtn) {
                muteBtn.addEventListener('click', () => {
                    isMuted = !isMuted;
                    muteBtn.classList.toggle('active', isMuted);
                    muteBtn.innerHTML = isMuted 
                        ? '<i class="fas fa-microphone-slash"></i>' 
                        : '<i class="fas fa-microphone"></i>';
                    
                    // Mute/unmute local audio tracks
                    if (localStream) {
                        localStream.getAudioTracks().forEach(track => {
                            track.enabled = !isMuted;
                        });
                    }
                });
            }

            // Speaker button
            if (speakerBtn) {
                speakerBtn.addEventListener('click', () => {
                    isSpeakerOn = !isSpeakerOn;
                    speakerBtn.classList.toggle('active', isSpeakerOn);
                    speakerBtn.innerHTML = isSpeakerOn 
                        ? '<i class="fas fa-volume-mute"></i>' 
                        : '<i class="fas fa-volume-up"></i>';
                    
                    // Control remote audio volume
                    const remoteAudio = document.getElementById('remoteAudio');
                    if (remoteAudio) {
                        remoteAudio.volume = isSpeakerOn ? 0 : 1;
                    }
                });
            }

            // Hold button
            if (holdBtn) {
                holdBtn.addEventListener('click', () => {
                    isOnHold = !isOnHold;
                    holdBtn.classList.toggle('active', isOnHold);
                    holdBtn.innerHTML = isOnHold 
                        ? '<i class="fas fa-play"></i>' 
                        : '<i class="fas fa-pause"></i>';
                    
                    // Pause/resume audio tracks
                    if (localStream) {
                        localStream.getAudioTracks().forEach(track => {
                            track.enabled = !isOnHold;
                        });
                    }

                    // Update status
                    const newStatus = isOnHold ? 'Call on hold' : 'Connected';
                    statusText.textContent = newStatus;
                });
            }
        }

        // Reject call
        rejectBtn.addEventListener('click', () => {
            clearInterval(ringtoneInterval);
            statusText.textContent = 'Declined';
            
            // Close connections
            if (peerConnection) {
                peerConnection.close();
            }
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
            }
            
            // Signal rejection to parent window via safeStorage
            safeStorage.setItem('callResponse', 'rejected');
            
            setTimeout(() => {
                window.close();
            }, 1000);
        });

        // Handle call timeout
        setTimeout(() => {
            if (statusText.textContent === 'Calling...') {
                clearInterval(ringtoneInterval);
                statusText.textContent = 'Missed Call';
                
                // Close connections
                if (peerConnection) {
                    peerConnection.close();
                }
                if (localStream) {
                    localStream.getTracks().forEach(track => track.stop());
                }
                
                // Signal timeout to parent window
                safeStorage.setItem('callResponse', 'timeout');
                
                setTimeout(() => {
                    window.close();
                }, 3000);
            }
        }, 60000); // 60 second timeout

        // Socket.IO handlers
        socket.on('webrtc_ice_candidate', async (data) => {
            try {
                if (data.candidate && peerConnection) {
                    await peerConnection.addIceCandidate(new RTCIceCandidate(data.candidate));
                }
            } catch (error) {
                console.error('Error adding ICE candidate:', error);
            }
        });

        // Handle page unload
        window.addEventListener('beforeunload', () => {
            if (peerConnection) {
                peerConnection.close();
            }
            if (localStream) {
                localStream.getTracks().forEach(track => track.stop());
            }
        });
    </script>
</body>
</html>
